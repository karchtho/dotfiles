#!/bin/bash

# React Component CLI (RC)
# Modern subcommand-based component generator
# Version 2.0.0

#==============================================================================
# SECTION 1: CONSTANTS & CONFIGURATION
#==============================================================================

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

VERSION="2.0.0"
SCRIPT_NAME="rc"

#==============================================================================
# SECTION 2: UTILITY FUNCTIONS
#==============================================================================

# Convert kebab-case to PascalCase (cross-platform compatible)
kebab_to_pascal() {
    local input="$1"
    local output=""
    local capitalize_next=true

    for (( i=0; i<${#input}; i++ )); do
        char="${input:$i:1}"
        if [ "$char" = "-" ]; then
            capitalize_next=true
        elif [ "$capitalize_next" = true ]; then
            output+="$(echo "$char" | tr '[:lower:]' '[:upper:]')"
            capitalize_next=false
        else
            output+="$char"
        fi
    done

    echo "$output"
}

# Convert kebab-case to camelCase
kebab_to_camel() {
    local input="$1"
    # First convert to PascalCase, then lowercase the first character
    local pascal=$(kebab_to_pascal "$input")
    echo "$(echo "${pascal:0:1}" | tr '[:upper:]' '[:lower:]')${pascal:1}"
}

# Convert PascalCase to kebab-case (cross-platform compatible)
pascal_to_kebab() {
    local input="$1"
    local output=""

    for (( i=0; i<${#input}; i++ )); do
        char="${input:$i:1}"
        if [[ "$char" =~ [A-Z] ]]; then
            if [ $i -gt 0 ]; then
                output+="-"
            fi
            output+="$(echo "$char" | tr '[:upper:]' '[:lower:]')"
        else
            output+="$char"
        fi
    done

    echo "$output"
}

# Parse nested path (e.g., "atoms/button" → "atoms" + "button")
parse_nested_path() {
    local full_path="$1"
    local base_dir="$2"

    local dir_path=$(dirname "$full_path")
    local component_name=$(basename "$full_path")

    if [ "$dir_path" = "." ]; then
        # No nested path
        echo "$base_dir"
        echo "$component_name"
    else
        # Has nested path
        echo "$base_dir/$dir_path"
        echo "$component_name"
    fi
}

# Validate we're in a React project
validate_project() {
    if [ ! -f "package.json" ]; then
        echo -e "${RED}Error: No package.json found. Are you in a React project root?${NC}"
        return 1
    fi
    return 0
}

# Check if file exists
check_file_exists() {
    local file_path="$1"
    if [ -f "$file_path" ]; then
        echo -e "${RED}Error: File already exists: $file_path${NC}"
        return 0  # Return 0 to indicate file exists (error condition)
    fi
    return 1  # Return 1 to indicate file doesn't exist (success)
}

# Create CSS file
create_css_file() {
    local css_path="$1"
    local css_class="$2"

    cat > "$css_path" << EOF
.${css_class} {
  /* Add your styles here */
}
EOF
}

# Print success message
print_success() {
    local type="$1"
    local folder="$2"
    local name="$3"
    local has_css="$4"
    local css_type="$5"

    echo -e "${GREEN}✓ $type created successfully!${NC}"
    echo -e "${BLUE}Structure:${NC}"
    echo "$folder/"
    echo "├── ${name}.jsx"
    if [ "$has_css" = true ]; then
        [ "$css_type" = "module" ] && echo "└── ${name}.module.css" || echo "└── ${name}.css"
    fi
}

#==============================================================================
# SECTION 3: TEMPLATE GENERATORS
#==============================================================================

# Basic functional component
template_component() {
    local component_name="$1"
    local css_import="$2"
    local css_class="$3"

    cat << EOF
${css_import}
const ${component_name} = () => {
  return (
    <div className={${css_class}}>
      {/* EXAMPLE content - Replace with your actual component JSX */}
      <h1>${component_name}</h1>
    </div>
  );
};

export default ${component_name};
EOF
}

# Component with useState
template_component_state() {
    local component_name="$1"
    local css_import="$2"
    local css_class="$3"

    cat << EOF
import { useState } from 'react';
${css_import}
const ${component_name} = () => {
  // EXAMPLE state - Rename and customize for your needs
  const [state, setState] = useState('');

  return (
    <div className={${css_class}}>
      {/* EXAMPLE content - Replace with your actual component JSX */}
      <h1>${component_name}</h1>
    </div>
  );
};

export default ${component_name};
EOF
}

# Component with useEffect
template_component_effect() {
    local component_name="$1"
    local css_import="$2"
    local css_class="$3"

    cat << EOF
import { useEffect } from 'react';
${css_import}
const ${component_name} = () => {
  useEffect(() => {
    // EXAMPLE effect - Add your side effects here (API calls, subscriptions, etc.)

    return () => {
      // EXAMPLE cleanup - Add cleanup logic if needed
    };
  }, []); // REQUIRED: Dependency array (customize based on your needs)

  return (
    <div className={${css_class}}>
      {/* EXAMPLE content - Replace with your actual component JSX */}
      <h1>${component_name}</h1>
    </div>
  );
};

export default ${component_name};
EOF
}

# Component with both useState and useEffect
template_component_state_effect() {
    local component_name="$1"
    local css_import="$2"
    local css_class="$3"

    cat << EOF
import { useState, useEffect } from 'react';
${css_import}
const ${component_name} = () => {
  // EXAMPLE state - Rename and customize for your needs
  const [state, setState] = useState('');

  useEffect(() => {
    // EXAMPLE effect - Add your side effects here

    return () => {
      // EXAMPLE cleanup - Add cleanup logic if needed
    };
  }, []); // REQUIRED: Dependency array (customize based on your needs)

  return (
    <div className={${css_class}}>
      {/* EXAMPLE content - Replace with your actual component JSX */}
      <h1>${component_name}</h1>
    </div>
  );
};

export default ${component_name};
EOF
}

# Layout component (with children prop)
template_layout() {
    local layout_name="$1"
    local css_import="$2"
    local css_class="$3"
    local use_state="$4"
    local use_effect="$5"

    local imports="import { "
    local hooks_added=false

    if [ "$use_state" = true ]; then
        imports+="useState"
        hooks_added=true
    fi

    if [ "$use_effect" = true ]; then
        [ "$hooks_added" = true ] && imports+=", "
        imports+="useEffect"
        hooks_added=true
    fi

    if [ "$hooks_added" = true ]; then
        imports+=" } from 'react';"
    else
        imports=""
    fi

    local state_code=""
    if [ "$use_state" = true ]; then
        state_code="  const [state, setState] = useState('');"
    fi

    local effect_code=""
    if [ "$use_effect" = true ]; then
        effect_code="
  useEffect(() => {
    // Effect logic here

    return () => {
      // Cleanup
    };
  }, []);"
    fi

    cat << EOF
${imports}
${css_import}
const ${layout_name} = ({ children }) => {
${state_code}${effect_code}

  return (
    <div className={${css_class}}>
      {/* EXAMPLE layout structure - Customize header, main, footer as needed */}
      <header>
        <h1>${layout_name} Header</h1>
      </header>
      <main>
        {children} {/* REQUIRED: Render children here */}
      </main>
      <footer>
        <p>${layout_name} Footer</p>
      </footer>
    </div>
  );
};

export default ${layout_name};
EOF
}

# Hook template
template_hook() {
    local hook_name="$1"
    local use_state="$2"
    local use_effect="$3"

    if [ "$use_state" = false ] && [ "$use_effect" = false ]; then
        # Simple hook
        cat << EOF
const ${hook_name} = (initialValue) => {
  // EXAMPLE logic - Replace with your custom hook logic

  return { /* EXAMPLE return values - Return whatever your hook needs */ };
};

export default ${hook_name};
EOF
    else
        # Hook with state/effect
        local imports="import { "
        local hooks_added=false

        if [ "$use_state" = true ]; then
            imports+="useState"
            hooks_added=true
        fi

        if [ "$use_effect" = true ]; then
            [ "$hooks_added" = true ] && imports+=", "
            imports+="useEffect"
        fi

        imports+=" } from 'react';"

        cat << EOF
${imports}

const ${hook_name} = () => {
  // EXAMPLE state - Customize for your hook's needs
  const [state, setState] = useState(null);

  useEffect(() => {
    // EXAMPLE effect - Add your hook logic here
  }, []); // REQUIRED: Dependency array

  return { state, setState }; // EXAMPLE return - Return whatever your hook needs
};

export default ${hook_name};
EOF
    fi
}

# Context provider template
template_context() {
    local context_name="$1"
    local with_state="$2"

    if [ "$with_state" = true ]; then
        cat << EOF
import { createContext, useContext, useState } from 'react';

const ${context_name}Context = createContext();

export const use${context_name} = () => {
  const context = useContext(${context_name}Context);
  if (!context) {
    throw new Error('use${context_name} must be used within ${context_name}Provider');
  }
  return context;
};

export const ${context_name}Provider = ({ children }) => {
  // EXAMPLE state - Replace with your actual context state
  const [state, setState] = useState(null);

  const value = {
    // EXAMPLE value - Add whatever you want to expose via context
    state,
    setState,
  };

  return (
    <${context_name}Context.Provider value={value}>
      {children} {/* REQUIRED: Render children */}
    </${context_name}Context.Provider>
  );
};

export default ${context_name}Provider;
EOF
    else
        cat << EOF
import { createContext, useContext } from 'react';

const ${context_name}Context = createContext();

export const use${context_name} = () => {
  const context = useContext(${context_name}Context);
  if (!context) {
    throw new Error('use${context_name} must be used within ${context_name}Provider');
  }
  return context;
};

export const ${context_name}Provider = ({ children }) => {
  const value = {
    // EXAMPLE value - Add your context values here
  };

  return (
    <${context_name}Context.Provider value={value}>
      {children} {/* REQUIRED: Render children */}
    </${context_name}Context.Provider>
  );
};

export default ${context_name}Provider;
EOF
    fi
}

# Basic Zustand store
template_store_basic() {
    local hook_name="$1"

    cat << EOF
import { create } from 'zustand';

const ${hook_name} = create((set) => ({
  // EXAMPLE State - Replace with your actual state properties
  count: 0,
  user: null,

  // EXAMPLE Actions - Replace with your actual actions
  // Use set() to update state: set({ propertyName: newValue })
  // Or use a function for state-based updates: set((state) => ({ count: state.count + 1 }))
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  setUser: (user) => set({ user }),
  reset: () => set({ count: 0, user: null }),
}));

export default ${hook_name};
EOF
}

# Zustand store with persist middleware
template_store_persist() {
    local hook_name="$1"
    local store_name="$2"

    cat << EOF
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

const ${hook_name} = create(
  persist(
    (set) => ({
      // EXAMPLE State - Replace with your actual state properties
      count: 0,
      user: null,

      // EXAMPLE Actions - Replace with your actual actions
      increment: () => set((state) => ({ count: state.count + 1 })),
      decrement: () => set((state) => ({ count: state.count - 1 })),
      setUser: (user) => set({ user }),
      reset: () => set({ count: 0, user: null }),
    }),
    {
      name: '${store_name}-storage', // REQUIRED: localStorage key (customize if needed)
    }
  )
);

export default ${hook_name};
EOF
}

# Zustand store with immer middleware
template_store_immer() {
    local hook_name="$1"

    cat << EOF
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

const ${hook_name} = create(
  immer((set) => ({
    // EXAMPLE State - Replace with your actual state properties
    todos: [],
    user: null,

    // EXAMPLE Actions - Replace with your actual actions
    // With immer, you can write "mutable" code that immer makes immutable
    addTodo: (todo) => set((state) => {
      state.todos.push(todo); // Looks mutable but immer handles it
    }),
    removeTodo: (id) => set((state) => {
      state.todos = state.todos.filter(t => t.id !== id);
    }),
    updateUser: (updates) => set((state) => {
      state.user = { ...state.user, ...updates };
    }),
  }))
);

export default ${hook_name};
EOF
}

# Zustand store with devtools
template_store_devtools() {
    local hook_name="$1"
    local store_name="$2"

    cat << EOF
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

const ${hook_name} = create(
  devtools(
    (set) => ({
      // EXAMPLE State - Replace with your actual state properties
      count: 0,
      user: null,

      // EXAMPLE Actions - Replace with your actual actions
      // With devtools: set(updates, false, 'actionName') to see actions in Redux DevTools
      increment: () => set((state) => ({ count: state.count + 1 }), false, 'increment'),
      decrement: () => set((state) => ({ count: state.count - 1 }), false, 'decrement'),
      setUser: (user) => set({ user }, false, 'setUser'),
      reset: () => set({ count: 0, user: null }, false, 'reset'),
    }),
    { name: '${store_name}' } // REQUIRED: DevTools name (customize if needed)
  )
);

export default ${hook_name};
EOF
}

#==============================================================================
# SECTION 4: SUBCOMMAND HANDLERS
#==============================================================================

# Handle component creation (rc c)
handle_component() {
    local component_path="$1"

    # Check for help first (before validation)
    if [ "$component_path" = "--help" ]; then
        show_help_component
        exit 0
    fi

    shift

    # Default values
    local use_state=false
    local use_effect=false
    local css_type="module"
    local create_css=true

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --state)
                use_state=true
                shift
                ;;
            --effect)
                use_effect=true
                shift
                ;;
            --state-effect)
                use_state=true
                use_effect=true
                shift
                ;;
            --css)
                css_type="regular"
                shift
                ;;
            --no-css)
                create_css=false
                shift
                ;;
            --help)
                show_help_component
                exit 0
                ;;
            *)
                echo -e "${RED}Error: Unknown flag '$1'${NC}"
                echo "Run 'rc c --help' for usage information"
                exit 1
                ;;
        esac
    done

    # Validate
    validate_project || exit 1

    if [ -z "$component_path" ]; then
        echo -e "${RED}Error: Component name is required${NC}"
        echo "Run 'rc c --help' for usage information"
        exit 1
    fi

    # Parse path
    local result=($(parse_nested_path "$component_path" "src/components"))
    local target_dir="${result[0]}"
    local component_name_kebab="${result[1]}"
    local component_name=$(kebab_to_pascal "$component_name_kebab")

    # Create structure
    local component_folder="$target_dir/$component_name_kebab"
    mkdir -p "$component_folder"

    local jsx_file="$component_folder/${component_name}.jsx"

    # Check if exists
    check_file_exists "$jsx_file" && exit 1

    # Prepare CSS import and class name
    local css_import=""
    local css_class="\"${component_name_kebab}\""
    local css_file=""

    if [ "$create_css" = true ]; then
        if [ "$css_type" = "module" ]; then
            css_file="$component_folder/${component_name}.module.css"
            css_import="import styles from './${component_name}.module.css';"
            css_class="styles.${component_name_kebab//-/}"
        else
            css_file="$component_folder/${component_name}.css"
            css_import="import './${component_name}.css';"
            css_class="\"${component_name_kebab}\""
        fi
    fi

    # Generate template
    if [ "$use_state" = true ] && [ "$use_effect" = true ]; then
        template_component_state_effect "$component_name" "$css_import" "$css_class" > "$jsx_file"
    elif [ "$use_state" = true ]; then
        template_component_state "$component_name" "$css_import" "$css_class" > "$jsx_file"
    elif [ "$use_effect" = true ]; then
        template_component_effect "$component_name" "$css_import" "$css_class" > "$jsx_file"
    else
        template_component "$component_name" "$css_import" "$css_class" > "$jsx_file"
    fi

    # Create CSS if needed
    if [ "$create_css" = true ]; then
        create_css_file "$css_file" "${component_name_kebab//-/}"
    fi

    # Success message
    print_success "Component" "$component_folder" "$component_name" "$create_css" "$css_type"
    echo ""
    echo -e "${YELLOW}Import with:${NC}"
    if [[ "$component_path" == *"/"* ]]; then
        local import_path=$(dirname "$component_path")
        echo "import ${component_name} from './components/${import_path}/${component_name_kebab}/${component_name}';"
    else
        echo "import ${component_name} from './components/${component_name_kebab}/${component_name}';"
    fi
}

# Handle page creation (rc p)
handle_page() {
    local page_path="$1"

    # Check for help first (before validation)
    if [ "$page_path" = "--help" ]; then
        show_help_page
        exit 0
    fi

    shift

    # Default values
    local use_state=false
    local use_effect=false
    local css_type="module"
    local create_css=true

    # Parse flags (same as component)
    while [[ $# -gt 0 ]]; do
        case $1 in
            --state)
                use_state=true
                shift
                ;;
            --effect)
                use_effect=true
                shift
                ;;
            --state-effect)
                use_state=true
                use_effect=true
                shift
                ;;
            --css)
                css_type="regular"
                shift
                ;;
            --no-css)
                create_css=false
                shift
                ;;
            --help)
                show_help_page
                exit 0
                ;;
            *)
                echo -e "${RED}Error: Unknown flag '$1'${NC}"
                echo "Run 'rc p --help' for usage information"
                exit 1
                ;;
        esac
    done

    # Validate
    validate_project || exit 1

    if [ -z "$page_path" ]; then
        echo -e "${RED}Error: Page name is required${NC}"
        echo "Run 'rc p --help' for usage information"
        exit 1
    fi

    # Parse path
    local result=($(parse_nested_path "$page_path" "src/pages"))
    local target_dir="${result[0]}"
    local page_name_kebab="${result[1]}"
    local page_name=$(kebab_to_pascal "$page_name_kebab")

    # Create structure
    local page_folder="$target_dir/$page_name_kebab"
    mkdir -p "$page_folder"

    local jsx_file="$page_folder/${page_name}.jsx"

    # Check if exists
    check_file_exists "$jsx_file" && exit 1

    # Prepare CSS import and class name
    local css_import=""
    local css_class="\"${page_name_kebab}\""
    local css_file=""

    if [ "$create_css" = true ]; then
        if [ "$css_type" = "module" ]; then
            css_file="$page_folder/${page_name}.module.css"
            css_import="import styles from './${page_name}.module.css';"
            css_class="styles.${page_name_kebab//-/}"
        else
            css_file="$page_folder/${page_name}.css"
            css_import="import './${page_name}.css';"
            css_class="\"${page_name_kebab}\""
        fi
    fi

    # Generate template (same as component)
    if [ "$use_state" = true ] && [ "$use_effect" = true ]; then
        template_component_state_effect "$page_name" "$css_import" "$css_class" > "$jsx_file"
    elif [ "$use_state" = true ]; then
        template_component_state "$page_name" "$css_import" "$css_class" > "$jsx_file"
    elif [ "$use_effect" = true ]; then
        template_component_effect "$page_name" "$css_import" "$css_class" > "$jsx_file"
    else
        template_component "$page_name" "$css_import" "$css_class" > "$jsx_file"
    fi

    # Add page comment to the template
    sed -i 's/<h1>\(.*\)<\/h1>/<h1>\1<\/h1>\n      {/* Page content *\/}/' "$jsx_file"

    # Create CSS if needed
    if [ "$create_css" = true ]; then
        create_css_file "$css_file" "${page_name_kebab//-/}"
    fi

    # Success message
    print_success "Page" "$page_folder" "$page_name" "$create_css" "$css_type"
    echo ""
    echo -e "${YELLOW}Import with:${NC}"
    if [[ "$page_path" == *"/"* ]]; then
        local import_path=$(dirname "$page_path")
        echo "import ${page_name} from './pages/${import_path}/${page_name_kebab}/${page_name}';"
    else
        echo "import ${page_name} from './pages/${page_name_kebab}/${page_name}';"
    fi
}

# Handle layout creation (rc l)
handle_layout() {
    local layout_path="$1"

    # Check for help first (before validation)
    if [ "$layout_path" = "--help" ]; then
        show_help_layout
        exit 0
    fi

    shift

    # Default values
    local use_state=false
    local use_effect=false
    local css_type="module"
    local create_css=true

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --state)
                use_state=true
                shift
                ;;
            --effect)
                use_effect=true
                shift
                ;;
            --state-effect)
                use_state=true
                use_effect=true
                shift
                ;;
            --css)
                css_type="regular"
                shift
                ;;
            --no-css)
                create_css=false
                shift
                ;;
            --help)
                show_help_layout
                exit 0
                ;;
            *)
                echo -e "${RED}Error: Unknown flag '$1'${NC}"
                echo "Run 'rc l --help' for usage information"
                exit 1
                ;;
        esac
    done

    # Validate
    validate_project || exit 1

    if [ -z "$layout_path" ]; then
        echo -e "${RED}Error: Layout name is required${NC}"
        echo "Run 'rc l --help' for usage information"
        exit 1
    fi

    # Parse path
    local result=($(parse_nested_path "$layout_path" "src/layouts"))
    local target_dir="${result[0]}"
    local layout_name_kebab="${result[1]}"
    local layout_name=$(kebab_to_pascal "$layout_name_kebab")

    # Create structure
    local layout_folder="$target_dir/$layout_name_kebab"
    mkdir -p "$layout_folder"

    local jsx_file="$layout_folder/${layout_name}.jsx"

    # Check if exists
    check_file_exists "$jsx_file" && exit 1

    # Prepare CSS import and class name
    local css_import=""
    local css_class="\"${layout_name_kebab}\""
    local css_file=""

    if [ "$create_css" = true ]; then
        if [ "$css_type" = "module" ]; then
            css_file="$layout_folder/${layout_name}.module.css"
            css_import="import styles from './${layout_name}.module.css';"
            css_class="styles.${layout_name_kebab//-/}"
        else
            css_file="$layout_folder/${layout_name}.css"
            css_import="import './${layout_name}.css';"
            css_class="\"${layout_name_kebab}\""
        fi
    fi

    # Generate layout template
    template_layout "$layout_name" "$css_import" "$css_class" "$use_state" "$use_effect" > "$jsx_file"

    # Create CSS if needed
    if [ "$create_css" = true ]; then
        create_css_file "$css_file" "${layout_name_kebab//-/}"
    fi

    # Success message
    print_success "Layout" "$layout_folder" "$layout_name" "$create_css" "$css_type"
    echo ""
    echo -e "${YELLOW}Import with:${NC}"
    if [[ "$layout_path" == *"/"* ]]; then
        local import_path=$(dirname "$layout_path")
        echo "import ${layout_name} from './layouts/${import_path}/${layout_name_kebab}/${layout_name}';"
    else
        echo "import ${layout_name} from './layouts/${layout_name_kebab}/${layout_name}';"
    fi
}

# Handle hook creation (rc h)
handle_hook() {
    local hook_name_input="$1"

    # Check for help first (before validation)
    if [ "$hook_name_input" = "--help" ]; then
        show_help_hook
        exit 0
    fi

    shift

    # Default values
    local use_state=false
    local use_effect=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --state)
                use_state=true
                shift
                ;;
            --effect)
                use_effect=true
                shift
                ;;
            --state-effect)
                use_state=true
                use_effect=true
                shift
                ;;
            --help)
                show_help_hook
                exit 0
                ;;
            *)
                echo -e "${RED}Error: Unknown flag '$1'${NC}"
                echo "Run 'rc h --help' for usage information"
                exit 1
                ;;
        esac
    done

    # Validate
    validate_project || exit 1

    if [ -z "$hook_name_input" ]; then
        echo -e "${RED}Error: Hook name is required${NC}"
        echo "Run 'rc h --help' for usage information"
        exit 1
    fi

    # Convert to PascalCase then add 'use' prefix if not present
    local hook_name=$(kebab_to_pascal "$hook_name_input")
    if [[ ! $hook_name == use* ]]; then
        hook_name="use${hook_name}"
    fi

    # Create hooks directory if it doesn't exist
    local hooks_dir="src/hooks"
    mkdir -p "$hooks_dir"
    local hook_file="$hooks_dir/${hook_name}.js"

    # Check if file already exists
    check_file_exists "$hook_file" && exit 1

    # Generate template
    template_hook "$hook_name" "$use_state" "$use_effect" > "$hook_file"

    # Success message
    echo -e "${GREEN}✓ Custom hook created successfully!${NC}"
    echo -e "${YELLOW}Path:${NC} $hook_file"
    echo ""
    echo -e "${YELLOW}Import with:${NC}"
    echo "import ${hook_name} from './hooks/${hook_name}';"
}

# Handle context creation (rc cx)
handle_context() {
    local context_path="$1"

    # Check for help first (before validation)
    if [ "$context_path" = "--help" ]; then
        show_help_context
        exit 0
    fi

    shift

    # Default value
    local with_state=true

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --no-state)
                with_state=false
                shift
                ;;
            --help)
                show_help_context
                exit 0
                ;;
            *)
                echo -e "${RED}Error: Unknown flag '$1'${NC}"
                echo "Run 'rc cx --help' for usage information"
                exit 1
                ;;
        esac
    done

    # Validate
    validate_project || exit 1

    if [ -z "$context_path" ]; then
        echo -e "${RED}Error: Context name is required${NC}"
        echo "Run 'rc cx --help' for usage information"
        exit 1
    fi

    # Parse path
    local result=($(parse_nested_path "$context_path" "src/context"))
    local target_dir="${result[0]}"
    local context_name_kebab="${result[1]}"
    local context_name=$(kebab_to_pascal "$context_name_kebab")

    # Create structure
    local context_folder="$target_dir/$context_name_kebab"
    mkdir -p "$context_folder"

    local jsx_file="$context_folder/${context_name}Provider.jsx"

    # Check if exists
    check_file_exists "$jsx_file" && exit 1

    # Generate template
    template_context "$context_name" "$with_state" > "$jsx_file"

    # Success message
    echo -e "${GREEN}✓ Context provider created successfully!${NC}"
    echo -e "${BLUE}Structure:${NC}"
    echo "$context_folder/"
    echo "└── ${context_name}Provider.jsx"
    echo ""
    echo -e "${YELLOW}Import with:${NC}"
    if [[ "$context_path" == *"/"* ]]; then
        local import_path=$(dirname "$context_path")
        echo "import { ${context_name}Provider, use${context_name} } from './context/${import_path}/${context_name_kebab}/${context_name}Provider';"
    else
        echo "import { ${context_name}Provider, use${context_name} } from './context/${context_name_kebab}/${context_name}Provider';"
    fi
}

# Handle store creation (rc s)
handle_store() {
    local store_name_input="$1"

    # Check for help first (before validation)
    if [ "$store_name_input" = "--help" ]; then
        show_help_store
        exit 0
    fi

    shift

    # Default values
    local use_persist=false
    local use_immer=false
    local use_devtools=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --persist)
                use_persist=true
                shift
                ;;
            --immer)
                use_immer=true
                shift
                ;;
            --devtools)
                use_devtools=true
                shift
                ;;
            --help)
                show_help_store
                exit 0
                ;;
            *)
                echo -e "${RED}Error: Unknown flag '$1'${NC}"
                echo "Run 'rc s --help' for usage information"
                exit 1
                ;;
        esac
    done

    # Validate
    validate_project || exit 1

    if [ -z "$store_name_input" ]; then
        echo -e "${RED}Error: Store name is required${NC}"
        echo "Run 'rc s --help' for usage information"
        exit 1
    fi

    # Convert to camelCase for store files
    local store_name_camel=$(kebab_to_camel "$store_name_input")
    # Ensure it ends with "Store"
    if [[ ! $store_name_camel =~ Store$ ]]; then
        store_name_camel="${store_name_camel}Store"
    fi

    # Hook name: useXxxStore
    local hook_name="use$(echo ${store_name_camel:0:1} | tr '[:lower:]' '[:upper:]')${store_name_camel:1}"

    # Create stores directory
    local stores_dir="src/stores"
    mkdir -p "$stores_dir"

    local store_file="$stores_dir/${store_name_camel}.js"

    # Check if exists
    check_file_exists "$store_file" && exit 1

    # Generate template based on flags
    if [ "$use_persist" = true ]; then
        template_store_persist "$hook_name" "$store_name_camel" > "$store_file"
    elif [ "$use_immer" = true ]; then
        template_store_immer "$hook_name" > "$store_file"
    elif [ "$use_devtools" = true ]; then
        template_store_devtools "$hook_name" "$store_name_camel" > "$store_file"
    else
        template_store_basic "$hook_name" > "$store_file"
    fi

    # Success message
    echo -e "${GREEN}✓ Zustand store created successfully!${NC}"
    echo -e "${YELLOW}File:${NC} $store_file"
    echo -e "${YELLOW}Hook:${NC} $hook_name"
    echo ""
    echo -e "${YELLOW}Import with:${NC}"
    echo "import ${hook_name} from './stores/${store_name_camel}';"
    echo ""
    echo -e "${CYAN}Usage example:${NC}"
    echo "const { count, increment } = ${hook_name}();"
}

#==============================================================================
# SECTION 5: HELP SYSTEM
#==============================================================================

show_help() {
    cat << EOF
${CYAN}rc${NC} - React Component CLI

${YELLOW}Usage:${NC} rc <command> <name> [options]

${YELLOW}Commands:${NC}
  ${GREEN}c, component${NC} <name>   Create a component in src/components/
  ${GREEN}p, page${NC} <name>        Create a page in src/pages/
  ${GREEN}l, layout${NC} <name>      Create a layout in src/layouts/
  ${GREEN}h, hook${NC} <name>        Create a custom hook in src/hooks/
  ${GREEN}cx, context${NC} <name>    Create a context provider in src/context/
  ${GREEN}s, store${NC} <name>       Create a Zustand store in src/stores/

${YELLOW}Global Options:${NC}
  --help                Show help for a command
  --version             Show version information

${YELLOW}Examples:${NC}
  rc c button                    # Create Button component
  rc c atoms/button --state      # Nested component with state
  rc p home-page                 # Create HomePage
  rc l main-layout               # Create MainLayout with children
  rc h auth                      # Create useAuth hook
  rc cx theme                    # Create ThemeProvider context
  rc s user --persist            # Create userStore with persistence

Run 'rc <command> --help' for more information on a command.
EOF
}

show_help_component() {
    cat << EOF
${CYAN}rc component${NC} - Create a React component

${YELLOW}Usage:${NC} rc c <name> [options]

${YELLOW}Arguments:${NC}
  <name>                Component name (supports nested paths)

${YELLOW}Options:${NC}
  --state               Add useState hook
  --effect              Add useEffect hook
  --state-effect        Add both useState and useEffect
  --css                 Use regular CSS instead of CSS modules
  --no-css              Don't create CSS file

${YELLOW}Examples:${NC}
  rc c button                    # Basic component with CSS module
  rc c user-card --state         # Component with state
  rc c data-fetcher --effect     # Component with effect
  rc c form --state-effect       # Component with both
  rc c atoms/button              # Nested in atoms folder
  rc c ui/forms/login --css      # Regular CSS instead of module
EOF
}

show_help_page() {
    cat << EOF
${CYAN}rc page${NC} - Create a page component

${YELLOW}Usage:${NC} rc p <name> [options]

${YELLOW}Arguments:${NC}
  <name>                Page name (supports nested paths)

${YELLOW}Options:${NC}
  --state               Add useState hook
  --effect              Add useEffect hook
  --state-effect        Add both useState and useEffect
  --css                 Use regular CSS instead of CSS modules
  --no-css              Don't create CSS file

${YELLOW}Examples:${NC}
  rc p home                      # Basic page
  rc p user/profile --state      # Nested page with state
  rc p dashboard --state-effect  # Page with state and effect
EOF
}

show_help_layout() {
    cat << EOF
${CYAN}rc layout${NC} - Create a layout component

${YELLOW}Usage:${NC} rc l <name> [options]

${YELLOW}Arguments:${NC}
  <name>                Layout name (supports nested paths)

${YELLOW}Options:${NC}
  --state               Add useState hook
  --effect              Add useEffect hook
  --state-effect        Add both useState and useEffect
  --css                 Use regular CSS instead of CSS modules
  --no-css              Don't create CSS file

${YELLOW}Note:${NC} Layouts automatically include a children prop.

${YELLOW}Examples:${NC}
  rc l main                      # Basic layout
  rc l admin/dashboard           # Nested layout
  rc l auth --state              # Layout with state
EOF
}

show_help_hook() {
    cat << EOF
${CYAN}rc hook${NC} - Create a custom hook

${YELLOW}Usage:${NC} rc h <name> [options]

${YELLOW}Arguments:${NC}
  <name>                Hook name (will be prefixed with 'use' if needed)

${YELLOW}Options:${NC}
  --state               Include useState
  --effect              Include useEffect
  --state-effect        Include both useState and useEffect

${YELLOW}Note:${NC} Hooks are created directly in src/hooks/ (no subfolder).

${YELLOW}Examples:${NC}
  rc h counter                   # Creates useCounter
  rc h use-auth --state          # Already has "use" prefix
  rc h fetch-data --effect       # With effect
EOF
}

show_help_context() {
    cat << EOF
${CYAN}rc context${NC} - Create a context provider

${YELLOW}Usage:${NC} rc cx <name> [options]

${YELLOW}Arguments:${NC}
  <name>                Context name (supports nested paths)

${YELLOW}Options:${NC}
  --no-state            Create context without state management

${YELLOW}Note:${NC} Creates XxxProvider component and useXxx hook.

${YELLOW}Examples:${NC}
  rc cx auth                     # Creates AuthProvider with state
  rc cx theme --no-state         # Context without state
EOF
}

show_help_store() {
    cat << EOF
${CYAN}rc store${NC} - Create a Zustand store

${YELLOW}Usage:${NC} rc s <name> [options]

${YELLOW}Arguments:${NC}
  <name>                Store name (will be converted to camelCase)

${YELLOW}Options:${NC}
  --persist             Add persist middleware (localStorage)
  --immer               Add immer middleware (mutable updates)
  --devtools            Add Redux DevTools integration

${YELLOW}Note:${NC} Store files use camelCase naming (userStore.js)
      Exported hooks use PascalCase (useUserStore)

${YELLOW}Examples:${NC}
  rc s user                      # Basic store
  rc s cart --persist            # With localStorage persistence
  rc s todos --immer             # With immer for mutable updates
  rc s app --devtools            # With Redux DevTools
EOF
}

#==============================================================================
# SECTION 6: MAIN DISPATCHER
#==============================================================================

main() {
    # No arguments → show help
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    # Parse subcommand
    local subcommand="$1"
    shift

    case "$subcommand" in
        c|component)
            handle_component "$@"
            ;;
        p|page)
            handle_page "$@"
            ;;
        l|layout)
            handle_layout "$@"
            ;;
        h|hook)
            handle_hook "$@"
            ;;
        cx|context)
            handle_context "$@"
            ;;
        s|store)
            handle_store "$@"
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        --version|-v)
            echo "rc version $VERSION"
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Unknown subcommand '$subcommand'${NC}"
            echo "Run 'rc --help' for usage information"
            exit 1
            ;;
    esac
}

main "$@"
